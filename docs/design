# システム設計書 & データベースアーキテクチャ

![System Architecture](system_architecture_jp.png)

## 1. システムアーキテクチャ (アーキテクト担当)

### 概要
`MemoLucky` システムは、Docker Composeを使用したマイクロサービス指向のアーキテクチャで構築されたモダンなWebアプリケーションです。フロントエンド、バックエンドAPI、データベース、キャッシュ/キューイング、オブジェクトストレージ、および翻訳などの補助サービスの間で関心を分離しています。

### アーキテクチャ構成図

```mermaid
graph TD
    Client[クライアントブラウザ] -->|HTTP/WebSocket| Frontend[フロントエンド (Vite/React)]
    Client -->|APIリクエスト| Backend[バックエンドAPI (FastAPI)]
    
    subgraph "アプリケーションクラスター"
        Frontend
        Backend
        Worker[Celeryワーカー]
    end
    
    subgraph "データ永続化 & キャッシュ"
        DB[(PostgreSQL 15)]
        Redis[(Redis 7)]
        MinIO[(MinIO オブジェクトストレージ)]
    end
    
    subgraph "外部/補助サービス"
        LibreTranslate[LibreTranslate 翻訳サービス]
    end

    Backend -->|読み書き| DB
    Backend -->|キャッシュ/キュー| Redis
    Backend -->|ファイル保存| MinIO
    Backend -->|翻訳リクエスト| LibreTranslate
    
    Worker -->|タスク消費| Redis
    Worker -->|更新| DB
    Worker -->|翻訳リクエスト| LibreTranslate
```

### コンポーネント詳細

| コンポーネント | 技術スタック | ポート (ホスト:コンテナ) | 説明 |
|-----------|------------|-----------------------|-------------|
| **Frontend** | React, Vite | 3000:5173 | 投稿の閲覧、プロフィール管理、チャットなどのユーザーインターフェース。 |
| **Backend** | Python, FastAPI | 8001:8000 | ビジネスロジック、認証、データオーケストレーションを処理するRESTful API。 |
| **Database** | PostgreSQL 15 | 5433:5432 | ユーザー、投稿、インタラクションのための主要なリレーショナルデータベース。 |
| **Redis** | Redis 7 | 6380:6379 | キャッシュおよびCeleryのメッセージブローカーとして使用されるインメモリデータストア。 |
| **MinIO** | MinIO | 9002:9000 | ユーザーアバターや投稿の添付ファイル用のS3互換オブジェクトストレージ。 |
| **Celery** | Python Celery | N/A | バックグラウンドジョブ（例：翻訳、通知）のための非同期タスクキュー。 |
| **Translator**| LibreTranslate | N/A:5000 | セルフホスト型の機械翻訳サービス。 |

---

## 2. データベース設計 (インフラ/DB担当)

### ER図 (実体関連図)

```mermaid
erDiagram
    User ||--o{ Post : "authors"
    User ||--o{ Comment : "writes"
    User ||--o{ Like : "gives"
    User ||--o{ Item : "owns"
    User ||--o{ UserBadge : "earns"
    User ||--o{ Favorite : "saves"
    User ||--o{ Follow : "follows/followed_by"
    
    Post ||--o{ Comment : "has"
    Post ||--o{ Like : "receives"
    Post ||--o{ Translation : "has"
    Post ||--o{ Favorite : "is_saved_as"
    
    Badge ||--o{ UserBadge : "awarded_to"
    
    Comment ||--o{ Comment : "replies_to"

    User {
        int id PK
        string email UK "一意, Not Null"
        string password_hash "Not Null"
        string nickname
        string role "デフォルト: user"
        string major
        int year
        string grade
        string language_preference
        string avatar_url
        string cover_image_url
        text bio
        datetime created_at
    }

    Post {
        int id PK
        int author_id FK
        text title "Not Null"
        text content "Not Null"
        string source_language "Not Null"
        string category
        text tags
        string restriction_type
        text image_urls
        json attachments
        boolean is_translated
        datetime created_at
    }

    Comment {
        int id PK
        int post_id FK
        int author_id FK
        text content "Not Null"
        int parent_id FK "自己参照"
        datetime created_at
    }

    Like {
        int id PK
        int post_id FK
        int user_id FK
        datetime created_at
    }

    Translation {
        int id PK
        int post_id FK
        string lang "Not Null"
        text translated_text "Not Null"
        datetime created_at
    }

    Badge {
        int id PK
        string name UK "一意, Not Null"
        text description
        string icon
    }

    UserBadge {
        int user_id PK, FK
        int badge_id PK, FK
        datetime awarded_at
    }

    Item {
        int id PK
        int user_id FK
        text title "Not Null"
        numeric price
        string status
        string category
        datetime created_at
    }

    Favorite {
        int id PK
        int post_id FK
        int user_id FK
        datetime created_at
    }

    Follow {
        int id PK
        int follower_id FK "following_idとの複合一意制約"
        int following_id FK
        datetime created_at
    }
```

### スキーマ詳細

#### 主キー (Primary Keys) & 制約 (Constraints)
- **主キー (PK)**: `UserBadge`（`user_id`, `badge_id`の複合主キー）を除くすべてのテーブルで、自動インクリメントの `Integer` `id` を主キーとして使用します。
- **外部キー (FK)**:
    - `posts.author_id` -> `users.id`
    - `comments.post_id` -> `posts.id`
    - `comments.author_id` -> `users.id`
    - `comments.parent_id` -> `comments.id` (スレッド形式コメントのための隣接リスト)
    - `likes.post_id` -> `posts.id`
    - `likes.user_id` -> `users.id`
    - `translations.post_id` -> `posts.id`
    - `user_badges.user_id` -> `users.id`
    - `user_badges.badge_id` -> `badges.id`
    - `items.user_id` -> `users.id`
    - `favorites.post_id` -> `posts.id` (Cascade Delete)
    - `favorites.user_id` -> `users.id` (Cascade Delete)
    - `follows.follower_id` -> `users.id` (Cascade Delete)
    - `follows.following_id` -> `users.id` (Cascade Delete)
- **一意制約 (Unique Constraints)**:
    - `users.email`: 重複アカウントを防止。
    - `badges.name`: バッジ名の重複を防止。
    - `follows`: 重複フォローを防ぐため、`(follower_id, following_id)` の複合一意制約を設定。

### 3. トランザクション処理設計

複数の関連レコードを同時に作成または更新する必要がある場合、データの整合性を保つためにトランザクションは不可欠です。

#### シナリオA: 添付ファイル付き投稿の作成
ユーザーが投稿を作成する際、投稿レコードを保存し、添付ファイルのメタデータを処理したり、初期翻訳タスクをトリガーしたりする必要がある場合があります。
*   **BEGIN TRANSACTION** (トランザクション開始)
*   **INSERT** into `posts` (title, content, author_id, ...) RETURNING id.
*   *(オプション)* ユーザー統計（投稿数など）を更新（非正規化している場合）。
*   **COMMIT** (コミット)
*   *コミット後フック*: Celeryタスク `translate_post(post_id)` をトリガー。

#### シナリオB: バッジの付与
アクション（例：「初投稿」）に基づいてバッジが付与される場合、バッジが一度だけ付与されることを保証する必要があります。
*   **BEGIN TRANSACTION**
*   **CHECK** if `UserBadge` exists for (user_id, badge_id).
*   存在しない場合:
    *   **INSERT** into `user_badges` (user_id, badge_id).
    *   **INSERT** into `notifications` (存在する場合) ユーザーに通知。
*   **COMMIT**

#### シナリオC: ユーザーのフォロー
*   **BEGIN TRANSACTION**
*   **INSERT** into `follows` (follower_id, following_id).
*   **COMMIT**
*   *エラーハンドリング*: 一意制約違反（すでにフォロー済み）が発生した場合、ロールバックして適切なエラーを返す。

### 4. Join (結合), 副問合せ & 複雑なクエリ

#### 1. フィード生成 (Join)
投稿と著者の詳細、および「いいね」数を取得します。
```sql
SELECT 
    p.id, p.title, p.content, p.created_at,
    u.nickname as author_name, u.avatar_url,
    COUNT(l.id) as like_count
FROM posts p
JOIN users u ON p.author_id = u.id
LEFT JOIN likes l ON p.id = l.post_id
GROUP BY p.id, u.id
ORDER BY p.created_at DESC;
```

#### 2. 「おすすめ」 (副問合せ)
現在のユーザーがフォローしているユーザーの投稿を検索します。
```sql
SELECT * FROM posts 
WHERE author_id IN (
    SELECT following_id 
    FROM follows 
    WHERE follower_id = :current_user_id
);
```

#### 3. コメントツリー (再帰CTE - 発展的)
深い階層のコメントツリーを取得する場合（`parent_id` は単純な隣接リストですが）。
```sql
WITH RECURSIVE comment_tree AS (
    SELECT id, content, parent_id, 0 as depth
    FROM comments
    WHERE post_id = :post_id AND parent_id IS NULL
    UNION ALL
    SELECT c.id, c.content, c.parent_id, ct.depth + 1
    FROM comments c
    INNER JOIN comment_tree ct ON c.parent_id = ct.id
)
SELECT * FROM comment_tree;
```

### 5. 正規化設計

データベーススキーマは、主に **第3正規形 (3NF)** に基づいて設計されており、冗長性を減らしデータの整合性を確保しています。

*   **第1正規形 (1NF - アトミックな値)**:
    *   すべてのカラムはアトミック（それ以上分割できない）な値を含みます。
    *   *例外*: `posts.tags` と `posts.image_urls` はカンマ区切りの文字列またはJSONとして保存されています。厳密なエンタープライズ環境では、これらは `tags` テーブルや `post_tags` テーブルに正規化される可能性があります。しかし、このアプリケーションの規模では、パフォーマンスとシンプルさ（結合の削減）のために、これらをテキスト/JSONとして保存することは実用的な設計上の選択です。

*   **第2正規形 (2NF - 部分関数従属の排除)**:
    *   すべての非キー属性は、主キーに対して完全関数従属しています。
    *   例: `UserBadge` は複合キー (`user_id`, `badge_id`) を持ちます。`awarded_at`（付与日時）は、片方だけでなく、両方の組み合わせに依存しています。

*   **第3正規形 (3NF - 推移的関数従属の排除)**:
    *   非キー属性は主キーのみに依存します。
    *   例: `posts` テーブルには `author_id` が含まれていますが、`author_email` や `author_nickname` は含まれていません。これらを取得するには `users` テーブルと結合します。これにより、更新時の不整合（例：ユーザーがニックネームを変更した場合に、過去のすべての投稿を更新する必要がない）を防ぎます。

#### 非正規化の検討事項
*   **パフォーマンス**: `posts.likes`（いいね数）は現在、`likes` テーブルに対する `COUNT()` で計算されています。アプリが数百万の「いいね」を扱う規模になった場合、読み取り時の高負荷な `COUNT(*)` クエリを避けるために、`posts` テーブルに `likes_count` カラムを追加し、トリガーやバックグラウンドワーカーで更新する「非正規化」を行う可能性があります。
