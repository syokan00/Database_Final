# パフォーマンス指標

## 概要

本ドキュメントでは、システムのパフォーマンス目標と測定方法を定義します。現在は開発・展示用途ですが、将来的な本番環境も考慮した指標とします。

## パフォーマンス目標

### 1. レスポンス時間（Response Time）

#### 目標値
- **ページ読み込み時間**: 2 秒以内
- **API レスポンス時間**: 1 秒以内（95 パーセンタイル）
- **画像読み込み時間**: 3 秒以内

#### 測定方法
- **フロントエンド**: ブラウザの DevTools（Network タブ）で測定
- **バックエンド**: FastAPI のミドルウェアでリクエスト処理時間をログ出力
- **ツール**: Chrome DevTools、Lighthouse、Apache Bench（ab）

#### 測定項目
- **Time to First Byte (TTFB)**: サーバーからの最初のバイトが到着するまでの時間
- **First Contentful Paint (FCP)**: 最初のコンテンツが表示されるまでの時間
- **Largest Contentful Paint (LCP)**: 最大のコンテンツが表示されるまでの時間
- **Time to Interactive (TTI)**: ページが完全にインタラクティブになるまでの時間

### 2. スループット（Throughput）

#### 目標値
- **同時接続数**: 10 ～ 50 ユーザー
- **リクエスト/秒**: 10 ～ 100 リクエスト/秒
- **データベースクエリ**: 100 クエリ/秒

#### 測定方法
- **負荷テスト**: Apache Bench、JMeter、Locust を使用
- **監視**: リアルタイムメトリクスの収集と可視化

#### テストシナリオ
```bash
# Apache Bench での負荷テスト例
ab -n 1000 -c 10 https://api.example.com/api/posts
```

### 3. 可用性（Availability）

#### 目標値
- **アップタイム**: 95% 以上（月間）
- **ダウンタイム**: 月間 36 時間以内
- **MTBF（平均故障間隔）**: 720 時間以上（30 日）

#### 測定方法
- **監視ツール**: Uptime Robot、Pingdom、Nagios
- **ヘルスチェック**: `/health` エンドポイントへの定期的なリクエスト
- **アラート**: ダウンタイム発生時の即座の通知

#### 計算式
```
可用性 (%) = (総時間 - ダウンタイム) / 総時間 × 100
```

### 4. リソース使用率

#### 目標値
- **CPU 使用率**: 平均 50% 以下、ピーク時 80% 以下
- **メモリ使用率**: 平均 60% 以下、ピーク時 85% 以下
- **ディスク使用率**: 70% 以下
- **ネットワーク帯域**: 平均 50% 以下

#### 測定方法
- **サーバー監視**: `htop`、`docker stats`、CloudWatch（将来）
- **データベース監視**: PostgreSQL の `pg_stat_statements` 拡張機能
- **ログ分析**: アプリケーションログとシステムログの分析

## パフォーマンス最適化

### 1. フロントエンド最適化

#### 実装済み
- **コード分割**: Vite による自動コード分割
- **画像最適化**: 適切な画像フォーマット（WebP、JPEG）の使用
- **キャッシュ**: ブラウザキャッシュと HTTP キャッシュヘッダー
- **バンドルサイズ**: 不要な依存関係の削除

#### 将来の改善案
- **CDN**: 静的ファイル（画像、CSS、JS）を CDN で配信
- **画像遅延読み込み**: `loading="lazy"` 属性の使用
- **Service Worker**: PWA 機能によるオフライン対応とキャッシュ

### 2. バックエンド最適化

#### 実装済み
- **データベースインデックス**: 頻繁にクエリされるカラムにインデックスを設定
- **接続プール**: SQLAlchemy の接続プールによる効率的な DB 接続
- **ページネーション**: 大量データの分割取得
- **レート制限**: Redis による API 呼び出し制限

#### 将来の改善案
- **クエリ最適化**: N+1 クエリ問題の解決、JOIN の最適化
- **キャッシュ**: Redis による頻繁にアクセスされるデータのキャッシュ
- **非同期処理**: Celery による重い処理の非同期実行
- **API レスポンス圧縮**: gzip 圧縮による転送データ量の削減

### 3. データベース最適化

#### 実装済み
- **インデックス**: 主キー、外部キー、頻繁に検索されるカラムにインデックス
- **トランザクション**: 適切なトランザクション境界の設定

#### 将来の改善案
- **クエリ分析**: `EXPLAIN ANALYZE` によるクエリパフォーマンス分析
- **パーティショニング**: 大規模テーブルのパーティショニング
- **読み取りレプリカ**: マスター・スレーブ構成による読み取り負荷分散
- **接続プールサイズの調整**: 同時接続数に応じた最適化

### 4. オブジェクトストレージ最適化

#### 実装済み
- **画像リサイズ**: アップロード時の適切なサイズへのリサイズ
- **適切なフォーマット**: JPEG、PNG、WebP の使い分け

#### 将来の改善案
- **CDN 統合**: CloudFront、Cloudflare による画像配信の高速化
- **画像最適化**: 自動的な WebP 変換と圧縮
- **遅延読み込み**: 画像の遅延読み込みによる初期読み込み時間の短縮

## パフォーマンス監視

### 監視ツール（将来の本番環境）

#### アプリケーションレベル
- **APM（Application Performance Monitoring）**: New Relic、Datadog、Elastic APM
- **ログ集約**: ELK Stack（Elasticsearch, Logstash, Kibana）
- **エラートラッキング**: Sentry

#### インフラレベル
- **サーバー監視**: Prometheus + Grafana
- **クラウド監視**: AWS CloudWatch、Google Cloud Monitoring
- **ネットワーク監視**: Pingdom、Uptime Robot

### 監視メトリクス

#### アプリケーションメトリクス
- リクエスト数/秒
- レスポンス時間（平均、中央値、95 パーセンタイル、99 パーセンタイル）
- エラー率
- アクティブユーザー数

#### インフラメトリクス
- CPU 使用率
- メモリ使用率
- ディスク I/O
- ネットワーク帯域
- データベース接続数
- データベースクエリ実行時間

## パフォーマンステスト計画

### テスト種類

#### 1. 負荷テスト（Load Testing）
- **目的**: 通常の負荷での動作確認
- **シナリオ**: 10 ～ 50 ユーザーが同時にアクセス
- **ツール**: Apache Bench、JMeter、Locust

#### 2. ストレステスト（Stress Testing）
- **目的**: システムの限界を確認
- **シナリオ**: 最大負荷を超えるリクエストを送信
- **ツール**: Apache Bench、JMeter、Locust

#### 3. 耐久テスト（Endurance Testing）
- **目的**: 長時間動作の安定性確認
- **シナリオ**: 24 時間連続で負荷をかける
- **ツール**: Apache Bench、JMeter、Locust

### テスト頻度
- **開発中**: 主要機能実装時に随時実施
- **リリース前**: 各リリース前に実施
- **本番環境**: 四半期ごとに実施

## パフォーマンス改善の優先順位

### 高優先度
1. **ページ読み込み時間の短縮**: ユーザー体験に直接影響
2. **API レスポンス時間の短縮**: アプリケーションの応答性向上
3. **データベースクエリの最適化**: ボトルネックになりやすい

### 中優先度
1. **画像最適化**: 転送データ量の削減
2. **キャッシュの導入**: 頻繁にアクセスされるデータの高速化
3. **CDN の導入**: 静的ファイルの配信高速化

### 低優先度
1. **コード分割の最適化**: バンドルサイズの削減
2. **非同期処理の導入**: 重い処理の非同期化
3. **データベースレプリケーション**: 読み取り負荷分散

## まとめ

本システムは開発・展示用途のため、現時点では以下の目標値を設定しています：

- **レスポンス時間**: 1 ～ 2 秒以内
- **同時接続数**: 10 ～ 50 ユーザー
- **可用性**: 95% 以上

将来的な本番環境では、より厳しい目標値（レスポンス時間 500ms 以内、可用性 99.9% 以上）を目指し、継続的な監視と最適化を行います。

